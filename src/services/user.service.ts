import { ApolloError } from "apollo-server-core";
import { Neo4jService } from './neo4j.service';
import { IUser, RelationshipType } from '../models/base';
import { CreateUserInput, UpdateUserInput, User } from '../models/user.model';
import { signJwt } from '../utils/jwt';
import bcrypt from 'bcrypt';
import { Service, Inject } from 'typedi';
import { Tweet } from "../models/tweet.model";

@Service()
class UserService {
    private neo4jService: Neo4jService;

    constructor(
        @Inject() neo4jService: Neo4jService
    ) {
        this.neo4jService = neo4jService;
    }

    async createUser(input: CreateUserInput): Promise<{ user: User; token: string }> {
        try {
            const existingUser = await this.neo4jService.findUserByUsername(input.username);
            if (existingUser) {
                throw new ApolloError('Username already exists', 'USERNAME_EXISTS');
            }

            const existingEmail = await this.neo4jService.executeQuery<{ u: IUser }>(
                'MATCH (u:User {email: $email}) RETURN u',
                { email: input.email }
            );
            
            if (existingEmail.records.length > 0) {
                throw new ApolloError('Email already in use', 'EMAIL_IN_USE');
            }

            const salt = await bcrypt.genSalt(10);
            const hashedPassword = await bcrypt.hash(input.password, salt);
            
            // Create the user in Neo4j
            const userData = await this.neo4jService.createUser({
                ...input,
                password: hashedPassword,
                // No need to pass id, it will be generated by Neo4j
            });
        
            if (!userData) {
                throw new ApolloError('Failed to create user', 'USER_CREATION_FAILED');
            }
            
            // Create a new User instance with the returned data
            const user = new User();
            Object.assign(user, {
                id: userData.id, // This should now be set by Neo4j
                username: userData.username,
                email: userData.email,
                name: userData.name || null,
                bio: userData.bio || null,
                pfp: userData.pfp || null,
                isVerified: userData.isVerified || false,
                createdAt: userData.createdAt ? new Date(userData.createdAt.toString()) : new Date(),
                updatedAt: userData.updatedAt ? new Date(userData.updatedAt.toString()) : new Date(),
            });
            
            // Generate JWT token
            const token = signJwt({ id: user.id });
            return { user, token };
        } catch (error) {
            console.error('Error in createUser:', error);
            throw error;
        }
    }

    async validatePassword({ username, password }: { username: string, password: string }): Promise<User | null> {
        try {
            const userData = await this.neo4jService.findUserByUsername(username);
            if (!userData || !userData.password) return null;
            
            const isValid = await bcrypt.compare(password, userData.password);
            if (!isValid) return null;
            
            // Create a new User instance and map the properties explicitly
            const user = new User();
            Object.assign(user, {
                id: userData.id,
                username: userData.username,
                email: userData.email,
                name: userData.name || null,
                bio: userData.bio || null,
                pfp: userData.pfp || null,
                isVerified: userData.isVerified || false,
                createdAt: userData.createdAt ? new Date(userData.createdAt.toString()) : new Date(),
                updatedAt: userData.updatedAt ? new Date(userData.updatedAt.toString()) : new Date(),
            });
            
            return user;
        } catch (error) {
            console.error('Error validating password:', error);
            return null;
        }
    }

    async findUserById(id: string): Promise<User | null> {
        const result = await this.neo4jService.findUserById(id);
        if (!result) return null;
        
        const user = new User();
        Object.assign(user, result);
        return user;
    }

    async findUserByUsername(username: string): Promise<User | null> {
        const result = await this.neo4jService.findUserByUsername(username);
        if (!result) return null;
        
        const user = new User();
        Object.assign(user, result);
        return user;
    }

    async updateUser(userId: string, input: UpdateUserInput): Promise<User | null> {
        const session = this.neo4jService.getDriver().session();
        try {
            const result = await session.run(
                `
                MATCH (u:User {id: $userId})
                SET u += $input, u.updatedAt = datetime()
                RETURN u
                `,
                { 
                    userId, 
                    input: {
                        ...input,
                        updatedAt: new Date().toISOString()
                    } 
                }
            );

            if (result.records.length === 0) {
                return null;
            }

            const userData = result.records[0].get('u').properties as IUser;
            const user = new User();
            Object.assign(user, userData);
            return user;
        } finally {
            await session.close();
        }
    }

    async followUser(userId: string, followerId: string) {
        // Check if users exist
        const [user, follower] = await Promise.all([
            this.findUserById(userId),
            this.findUserById(followerId)
        ]);

        if (!user || !follower) {
            throw new ApolloError('User not found', 'USER_NOT_FOUND');
        }

        // Check if already following
        const existingFollow = await this.neo4jService.executeQuery(
            `
            MATCH (f:User {id: $followerId})-[r:FOLLOWS]->(u:User {id: $userId})
            RETURN r
            `,
            { userId, followerId }
        );

        if (existingFollow.records.length > 0) {
            return { success: true, message: 'Already following this user' };
        }

        // Create follow relationship
        await this.neo4jService.createRelationship(
            followerId,
            userId,
            RelationshipType.FOLLOWS
        );

        return { success: true, message: 'Successfully followed user' };
    }

    async unfollowUser(userId: string, followerId: string) {
        await this.neo4jService.deleteRelationship(
            followerId,
            userId,
            RelationshipType.FOLLOWS
        );

        return { success: true };
    }

    async getAllUsers(): Promise<User[]> {
        const result = await this.neo4jService.executeQuery(
            `
            MATCH (u:User)
            OPTIONAL MATCH (u)-[:POSTED]->(t:Tweet)
            OPTIONAL MATCH (u)-[:LIKES_TWEET]->(lt:Tweet)
            RETURN u, collect(DISTINCT t) as tweets, collect(DISTINCT lt) as likedTweets
            `,
            {}
        );

        return result.records.map(record => {
            const userData = record.get('u').properties as IUser;
            const user = new User();
            Object.assign(user, userData);

            // Map tweets (if any)
            const tweetsRaw = record.get('tweets') || [];
            user.tweets = (tweetsRaw || []).filter(Boolean).map((tweetNode: any) => {
                if (!tweetNode) return null;
                const t = tweetNode.properties;
                return {
                    id: t.id,
                    text: t.text,
                    media: t.media || [],
                    authorId: t.authorId,
                    createdAt: t.createdAt,
                    updatedAt: t.updatedAt,
                    // Add any other tweet fields as needed
                };
            }).filter(Boolean);

            // Map liked tweets (if any)
            const likedTweetsRaw = record.get('likedTweets') || [];
            user.likedTweets = (likedTweetsRaw || []).filter(Boolean).map((tweetNode: any) => {
                if (!tweetNode) return null;
                const t = tweetNode.properties;
                return {
                    id: t.id,
                    text: t.text,
                    media: t.media || [],
                    authorId: t.authorId,
                    createdAt: t.createdAt,
                    updatedAt: t.updatedAt,
                    // Add any other tweet fields as needed
                };
            }).filter(Boolean);

            return user;
        });
    }

    async getFollowers(userId: string): Promise<User[]> {
        const result = await this.neo4jService.executeQuery(
            `
            MATCH (u:User {id: $userId})<-[:FOLLOWS]-(follower:User)
            RETURN follower
            `,
            { userId }
        );

        return result.records.map(record => {
            const userData = record.get('follower').properties as IUser;
            const user = new User();
            Object.assign(user, userData);
            return user;
        });
    }

    async getFollowings(userId: string): Promise<User[]> {
        const result = await this.neo4jService.executeQuery(
            `
            MATCH (u:User {id: $userId})-[:FOLLOWS]->(following:User)
            RETURN following
            `,
            { userId }
        );

        return result.records.map(record => {
            const userData = record.get('following').properties as IUser;
            const user = new User();
            Object.assign(user, userData);
            return user;
        });
    }

    async getLikedTweets(userId: string): Promise<any[]> {
        const result = await this.neo4jService.executeQuery(
            `
            MATCH (u:User {id: $userId})-[r:LIKES_TWEET]->(t:Tweet)
            RETURN t
            `,
            { userId }
        );

        return result.records.map(record => record.get('t').properties);
    }

    /**
     * Deletes a user and all their relationships
     * @param userId The ID of the user to delete
     * @returns Boolean indicating if the deletion was successful
     */
    async deleteUser(userId: string): Promise<boolean> {

        try {
            // Delete all user relationships and the user node in a single transaction
            const result = await this.neo4jService.executeQuery(
                `
                MATCH (u:User {id: $userId})
                // Delete all relationships
                OPTIONAL MATCH (u)-[r1:FOLLOWS]->()
                DELETE r1
                WITH u
                OPTIONAL MATCH (u)<-[r2:FOLLOWS]-()
                DELETE r2
                WITH u
                // Delete the user node
                DETACH DELETE u
                RETURN COUNT(u) > 0 as deleted
                `,
                { userId }
            );

            return result.records[0]?.get('deleted') === true;
        } catch (error) {
            console.error('Error deleting user:', error);
            throw new ApolloError(
                'Failed to delete user account',
                'USER_DELETION_FAILED',
                { originalError: error as Error }
            );
        }
    }

    async getRecommendedTweets(userId: string, limit: number = 10): Promise<any[]> {
        try {
            // Get recommended tweets based on:
            // 1. Tweets from followed users
            // 2. Popular tweets from 2nd degree connections
            // 3. Tweets liked by followed users
            const result = await this.neo4jService.executeQuery(
                `
                MATCH (u:User {id: $userId})

                // Tweets posted by followings (excluding user's own tweets)
                OPTIONAL MATCH (u)-[:FOLLOWS]->(f:User)-[:POSTED]->(ft:Tweet)
                WHERE f.id <> $userId

                // Tweets liked by followings (excluding user's own tweets)
                OPTIONAL MATCH (u)-[:FOLLOWS]->(f2:User)-[:LIKES_TWEET]->(lt:Tweet)
                WHERE f2.id <> $userId

                // Tweets the user has liked
                OPTIONAL MATCH (u)-[:LIKES_TWEET]->(myLiked:Tweet)

                WITH COLLECT(DISTINCT ft) + COLLECT(DISTINCT lt) + COLLECT(DISTINCT myLiked) AS allTweets, u
                UNWIND allTweets AS tweet
                WITH DISTINCT tweet, u
                WHERE tweet IS NOT NULL

                // Get author
                MATCH (author:User)-[:POSTED]->(tweet)

                // Check if the user has liked the tweet
                OPTIONAL MATCH (u)-[liked:LIKES_TWEET]->(tweet)

                RETURN tweet, author, liked IS NOT NULL AS isLiked
                ORDER BY tweet.createdAt DESC
                LIMIT toInteger($limit)
                `,
                { userId, limit }
            );

            return result.records.map(record => {
                const tweetData = record.get('tweet').properties;
                const authorData = record.get('author').properties;
                const isLiked = record.get('isLiked');

                const tweet = new Tweet();
                Object.assign(tweet, {
                    ...tweetData,
                    createdAt: new Date(tweetData.createdAt.toString()),
                    updatedAt: new Date(tweetData.updatedAt.toString()),
                    isLiked,
                    author: {
                        id: authorData.id,
                        username: authorData.username,
                        name: authorData.name || null,
                        pfp: authorData.pfp || null,
                        isVerified: authorData.isVerified || false
                    }
                });

                return tweet;
            });
        } catch (error) {
            console.error('Error getting recommended tweets:', error);
            throw new ApolloError(
                'Failed to get recommended tweets',
                'RECOMMENDED_TWEETS_ERROR',
                { originalError: error as Error }
            );
        }
    }
}

export { UserService };